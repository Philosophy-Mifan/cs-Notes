```cpp
//Algorithm篇（C++），配合LeetCode和Luogu使用，所以在正式阅读本文之前，请先注册属于自己的账号，并且熟悉两个平台的用法。

//请在学习C++基础篇以及数据结构后阅读本文，本文重点教你如何刷题，以及部分常见算法题的思路。
//在学习每一章节之前，请先预习各个章节的第一部分，也就是至少先将题看一遍，且有自己大概的思路，再来学习本笔记。
//本笔记旨在整理课程内容，其目标如下：
1、学会做题——分析题意，寻找思路/确定算法，把思路转换成代码
2、巩固《数据结构》课程中的算法
3、学习一些《数据结构》课程中没有涉及到，但常用的算法：在算法比赛中（不包含ACM），春秋招笔试，考研复试（上机）中常出现的算法
4、课程结束后，希望大家都可以独立的在oj上刷题练习
```

## Chapter 0 序言

再次提醒，在学习对应的章节时，请务必确定自己学习了相应的数据结构，以及复习了相应的STL语法（可见《算法笔记》第6章）

1. 在本文中所使用的语言为C/C++，在学习以及自行做题时可以选用自己的主语言，并且添加到本文中以完善属于自己的笔记；
2. 本文中的例题均选自洛谷和Leetcode，自行做题时可以使用任意刷题网站（OJ）；
3. 对参加ACM（ICPC/CCPC）有帮助嘛？有，但远远不够，本文涉及到的算法只覆盖了蓝桥杯等比赛的**大部分**出题范围；
4. 在刷题时遇到不会的题，请**参照**题解（不要**照抄**），通过看题解中的思路转换为自己的思路，并自行完成代码的编写，如果一个题解看不懂，不要犹豫，换一个题解继续看，总会遇到适合你的题解，使用AI进行适当的辅助学习是事半功倍的。

在各平台提交题解时，请不要使用各平台网站自带的编译器，使用自己的编译器在本地通过测试用例后，再复制到网页中，在提交时你可能会遇到如下提示：

1. 答案正确 (Accepted, AC)：单点测试，每通过一组数据，就会返回一个AC；多点测试只有通过是有的数据之后才回返回一个AC
2. 编译错误(Compile Error, CE)：代码没有通过编译，看本地编译器是否能正常编译后，修改后重新提交
3. 答案错误(Wrong Answer, WA)：代码有漏洞或者是使用了错误的算法导致结果错误
4. 运行超时(Time Limit Exceeded, TLE)：运行时间超过允许上限，**死循环**的情况最常见
5. 运行错误(Running Error, RE)：造成这一错误的可能性很多：非法访问内存，浮点错误，递归爆栈等
6. 内存超限(Memory Limit Exceeded, MLE)：一般数组太大会导致这个问题
7. 格式错误(Presentation Error, PE)：最接近Accepted的错误，一般由多输出空格或者换行导致
8. 输出超限(Output Limit Exceeded, OLE)：一般由输出了大量调试信息或者特殊数据导致死循环输出导致



## Chapter 1 枚举&暴力

- 枚举：是基于已有知识来猜测答案的一种问题求解策略。枚举的思想是不断地猜测，从可能的答案集合中一一尝试，然后再判断题目的条件是否成立，枚举每一种可能性。
- 暴力：直接模拟题目中要求的操作来求解。模拟题目通常具有码量大、操作多的特点，由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的，但是其思路一般较为简单；还有一种搜索方式叫暴力搜索（暴搜）

:exclamation:枚举和暴力不做严格区分。



做题步骤：读题面，分析题意 -> 看示例，分析样例 -> 看数据范围，确定时间复杂度(1s = 10^8^) -> 找思路，写代码，本地运行测试，提交

### P1003 [NOIP 2011 提高组] 铺地毯

https://www.luogu.com.cn/problem/P1003

**题目描述**

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。

**输入格式**

输入共 $n + 2$ 行。

第一行，一个整数 $n$，表示总共有 $n$ 张地毯。

接下来的 $n$ 行中，第 $i+1$ 行表示编号 $i$ 的地毯的信息，包含四个整数 $a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 $(a, b)$ 以及地毯在 $x$ 轴和 $y$ 轴方向的长度。

第 $n + 2$ 行包含两个整数 $x$ 和 $y$，表示所求的地面的点的坐标 $(x, y)$。

**输出格式**

输出共 $1$ 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `-1`。

**输入输出样例 #1**

**输入 #1**

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

**输出 #1**

```
3
```

**输入输出样例 #2**

**输入 #2**

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5
```

**输出 #2**

```
-1
```

**说明/提示**

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

<img src="https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png" alt=" " style="zoom:35%;" />

【数据范围】

对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

**思路**

从后往前枚举地毯，如果有一个地毯满足条件则直接输出，并退出；如果没有地毯满足则返回-1。(满足条件：点的坐标在地毯的覆盖范围内)

思路解：[P1003.cpp](source codes\Part I 枚举&暴力\P1003.cpp) 



### LC59. 螺旋矩阵II

给你一个正整数 `n` ，生成一个包含 `1` 到 n^2^ 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

 https://leetcode.cn/problems/spiral-matrix-ii/description/

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" style="zoom:50%;" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**数据范围：**

- `1 <= n <= 20`

**思路：**

生成一个n × n的空矩阵mat，随后模拟整个向内环绕的填入过程：定义当前左右上下边界`left`, `right`, `top`, `bottom`，当num <= n * n时，始终按照从左到右、从上到下、从右到左、从下到上，填入顺序循环，每次填入后：
执行num += 1：得到下一个需要填入的数字；
更新边界：例如第一轮从左到右填完以后，上边界`top += 1`，相当于上边界向内缩1,
最终返回mat。

思路解： [LC59.cpp](source codes\Part I 枚举&暴力\LC59.cpp)



### P1328 [NOIP 2014 提高组] 生活大爆炸版石头剪刀布

https://www.luogu.com.cn/problem/P1328

**题目背景**

NOIP2014 提高组 D1T1

**题目描述**

石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第 8 集中出现了一种石头剪刀布的升级版游戏。

升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：

斯波克:《星际迷航》主角之一。

蜥蜴人:《星际迷航》中的反面角色。

这五种手势的胜负关系如表一所示,表中列出的是甲对乙的游戏结果。

<img src="https://cdn.luogu.com.cn/upload/pic/1346.png" alt="" style="zoom:60%;" />

现在，小 A 和小 B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小 A 以 `石头-布-石头-剪刀-蜥蜴人-斯波克` 长度为 $6$ 的周期出拳,那么他的出拳序列就是 `石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-...`，而如果小 B 以 `剪刀-石头-布-斯波克-蜥蜴人` 长度为 $5$ 的周期出拳,那么他出拳的序列就是 `剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-...`。

已知小 A 和小 B 一共进行 $N$ 次猜拳。每一次赢的人得 $1$ 分，输的得 $0$ 分；平局两人都得 $0$ 分。现请你统计 $N$ 次猜拳结束之后两人的得分。

**输入格式**

第一行包含三个整数：$N,N_A,N_B$，分别表示共进行 $N$ 次猜拳、小 A 出拳的周期长度，小 B 出拳的周期长度。数与数之间以一个空格分隔。

第二行包含 $N_A$ 个整数,表示小 A 出拳的规律,第三行包含 $N_B$ 个整数，表示小 B 出拳的规律。其中，$0$ 表示 `剪刀`，$1$ 表示 `石头`，$2$ 表示 `布`，$3$ 表示 `蜥蜴人`，$4$ 表示 `斯波克`。数与数之间以一个空格分隔。

**输出格式**

输出一行，包含两个整数，以一个空格分隔，分别表示小 A、小 B 的得分。

**输入输出样例 #1**

**输入 #1**

```
10 5 6
0 1 2 3 4
0 3 4 2 1 0
```

**输出 #1**

```
6 2
```

**输入输出样例 #2**

**输入 #2**

```
9 5 5
0 1 2 3 4
1 0 3 2 4
```

**输出 #2**

```
4 4
```

**说明/提示**

对于 $100\%$ 的数据，$0 < N \leq 200, 0 < N_A \leq 200, 0 < N_B \leq 200$ 。

**思路：**

我们可以将题目中所展示的游戏结果转换为得分表，整理成一个整数型的二维数组，我们在查看结果时只要将取这个数组的(`a[i]`, `b[j]`)便可以知道结果。出拳都是有周期性规律的，其周期长度不一定一致。

思路解：[P1328.cpp](source codes\Part I 枚举&暴力\P1328.cpp) 



## Chapter 2 前缀和&差分

前缀和可以简单理解为 "数列的前i项的和" ，是一种重要的**预处理**方式。
**一维**：有N个的正整数放到数组A里，现在要求一个新的数组B，新数组的第`i`个数`B[i]`是原数组A第0到第`i`个数的和。
**二维**：有$n*m$个的正整数$n*m$的二维数组A中，现在要求一个新的二维数组数组B，新数组的`B[i][j]`是原数组`A[0][0]`到`A[i][j]`的和。（矩形范围）

多维前缀和的普通求解方法几乎都是基于<u>**容斥原理**</u>：在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计数的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。

比如我们有这样一个数组$a$，可以视为二维数组：

```
1 2 4 3
5 1 2 4
6 3 5 9
```

我们定义一个矩阵$sum$使得$sum_{z,y} = \sum^z_{i=1}\sum^y_{j=1}a_{i,j}$，那么这个矩阵长这样：

```
1  3  7  10
6  9  15 22
12 18 29 45
```

第一个问题就是递推求$sum$的过程，$sum_{i,j}=sum_{i-1,j}+sum_{i,j-1}-sum_{i-1,j-1}+a_{i,j} $ 因为同时加了$sum_{i-1,j}$和$sum_{i,j-1}$，重复了$sum_{i-1,j-1}$，减去，计算以及重叠区域如下所示：

<img src="Pictures/prefix sum algorithm-1.png" alt="" style="zoom:50%;" /><img src = "Pictures/prefix sum algorithm-2.png" alt="" style="zoom:50%;" /><img src="Pictures/prefix sum algorithm-3.png" alt="3" style="zoom:50%;" />

第二个问题就是如何应用，譬如求$(x_1,y_1)-(x_2,y_2)$子矩阵的和，那么，根据类似的思考过程，易得答案为：$sum_{x_2,y_2}-sum_{x_1-1,y_2}-sum_{x_2,y_1-1}+sum_{x_1-1,y_1-1}$
<img src="Pictures/prefix sum algorithm-4.png" alt="" style="zoom:40%;" /><img src="Pictures/prefix sum algorithm-5.png" alt="" style="zoom:40%;" />
<img src="Pictures/prefix sum algorithm-6.png" alt="" style="zoom:40%;" /><img src="Pictures/prefix sum algorithm-7.png" alt="" style="zoom:40%;" />

:question:如果要求中间子矩阵（非对角线）的和，可以用以下的方法：

差分是一种和前缀相对的策略，可以当做是求和的逆运算。

$$ b_i=\begin{cases}   a_i-a_{i-1} & i\in[2,n] \\ a_1 & i=1 \end{cases} $$

**差分标记数组**：可以维护<u>多次</u>、<u>多对</u>和<u>序列</u>的一个区间加上一个数，并在最后询问某一位的数，<u>其修改操作一定要在查询操作之前</u>。

如果有$n$个数，其前缀和为`sum[]`，现在求`[l, r]`的和其公式为：`ans = sum[r] - sum[l-1]`，其推导如下：
`sum[r] = a[1] + a[2] + ... + a[l-1] + a[l] + ... + a[r]`①
`sum[l-1] = a[1] + a[2] + ... +a[l-1]`②
由$①-②$得`ans = sum[r] - sum[l-1]`

上述问题如果在二维中（如下图所示），求`(x1, y1) -> (x2, y2)`的值

<img src="Pictures/prefix sum algorithm-8.png" alt="" style="zoom:50%;" />
其计算结果：$ans = sum[x_2][y_2]-sum[x_2][y_1-1]-sum[x_1-1][y_2]+sum[x_1-1][y_1-1]$

 差分标记数组的目的是解决**元素变化**，为了区间修改而生的，只改变两个端点的值，就能在$O(1)$的时间内给一整段区间加减数值，如下在一维中有$m$个操作:
`l, r, q`：在区间`[l, r]`内的元素增加`q`，如1,4,1的演示如下图所示

<img src="Pictures/prefix sum algorithm-9.png" alt="" style="zoom:50%;" />

```cpp
//一维的伪代码实现
int b[105];		//差分标记数组
int sum[b];
while(m > 0){
    cin >> l >> r >> q;
    b[l] += q;
    b[r + l] -= q;
}
for(int i = 1; i <= n; i++){
    sumb[i] = sum[i - 1] + b[i];
    cout << a[i] + sumb[i];
}
```

当$m=3$ $l_1=3,r_1=6,q_1=-2\\ l_2=1,r_2=4,q_2=3\\ l_3=5,r_3=7,q_3=-1$时，如下图所示

<img src="Pictures/prefix sum algorithm-10.png" alt="" style="zoom:50%;" />

在二维中有如下m个操作：
$x_1,x_2,y_1,y_2,q$：在区间$[(x_1,y_1)(x_2,y_2)]$内的元素增加$q$，如下图操作所示：

<img src="Pictures/prefix sum algorithm-11.png" alt="" style="zoom:75%;" />

### B3612 【深进1.例1】求区间和

**题目描述**

给定 $n$ 个正整数组成的数列 $a_1, a_2, \cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。

**输入格式**

第一行包含一个正整数 $n$，表示序列的长度。

第二行包含 $n$ 个正整数 $a_1,a_2, \cdots ,a_n$。

第三行包含一个正整数 $m$，表示区间的数量。

接下来 $m$ 行，每行包含两个正整数 $l_i,r_i$，满足 $1\le l_i\le r_i\le n$。

**输出格式**

共 $m$ 行，其中第 $i$ 行包含一个正整数，表示第 $i$ 组答案的询问。

**输入输出样例** #1

**输入 #1**

```
4
4 3 2 1
2
1 4
2 3
```

**输出 #1**

```
10
5
```

**说明/提示**

**样例解释**

第 $1$ 到第 $4$ 个数加起来和为 $10$。第 $2$ 个数到第 $3$ 个数加起来和为 $5$。

**数据范围**

对于 $50 \%$ 的数据：$n,m\le 1000$；

对于 $100 \%$ 的数据：$1 \le n, m\le 10^5$，$1 \le a_i\le 10^4$。

**思路**

同上前缀和和差分

[][]

思路解：[B3612.cpp](source codes\Part II 前缀和&差分\B3612.cpp)



### P1387 最大正方形

**题目描述**

在一个 $n\times m$ 的只包含 $0$ 和 $1$ 的矩阵里找出一个不包含 $0$ 的最大正方形，输出边长。

保证矩阵里有至少一个 $1$。

**输入格式**

输入文件第一行为两个整数 $n,m(1\leq n,m\leq 100)$，接下来 $n$ 行，每行 $m$ 个数字，用空格隔开，$0$ 或 $1$。

**输出格式**

一个整数，最大正方形的边长。

**输入输出样例 #1**

**输入 #1**

```
4 4
0 1 1 1
1 1 1 0
0 1 1 0
1 1 0 1
```

**输出 #1**

```
2
```

**思路**

枚举边从大到小，当矩阵和与面积相等时满足条件，则输出。矩阵和需要用到前缀和，前缀和就要使用到差分，用flag标记0和1，只需要关注右下角的坐标以及向上和向左延伸遍历边的长度范围内的矩阵和是否与面积相等即可。

思路解：[P1387.cpp](source codes\Part II 前缀和&差分\P1387.cpp)



### P3397 地毯

**题目背景**

[原题](/problem/P13787)

**题目描述**

在 $n\times n$ 的格子上有 $m$ 个地毯。

给出这些地毯的信息，问每个点被多少个地毯覆盖。

**输入格式**

第一行，两个正整数 $n,m$。意义如题所述。

接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。

**输出格式**

输出 $n$ 行，每行 $n$ 个正整数。

第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。

**输入输出样例 #1**

**输入 #1**

```
5 3
2 2 3 3
3 3 5 5
1 2 1 4
```

**输出 #1**

```
0 1 1 1 0
0 1 1 0 0
0 1 2 1 1
0 0 1 1 1
0 0 1 1 1
```

**说明/提示**

**样例解释**

覆盖第一个地毯后：

| $0$  | $0$  | $0$  | $0$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $0$  | $0$  | $0$  | $0$  |
| $0$  | $0$  | $0$  | $0$  | $0$  |

覆盖第一、二个地毯后：

| $0$  | $0$  | $0$  | $0$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $2$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |

覆盖所有地毯后：

| $0$  | $1$  | $1$  | $1$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $2$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |

---

**数据范围**

对于 $20\%$ 的数据，有 $n\le 50$，$m\le 100$。

对于 $100\%$ 的数据，有 $n,m\le 1000$。

**思路**

纯公式，无

思路解：[P3397.cpp](source codes\Part II 前缀和&差分\P3397.cpp)



## Chapter 3 尺取法/滑动窗口

尺取法：一种利用双指针遍历获取满足条件的区间（滑动窗口）的算法。为一种线性算法，过程为：枚举$r$，不断得到合法区间。记$(l,r)$为一个序列内以$r$为终点的合法区间，然后枚举$l$，随着$l$的增大，区间不断缩小，直至不合法为止，时间复杂度为$O(n)$。

尺取法需要满足的条件：区间权值大小满足随区间长度**单调变化**，即区间越长区间权值越小或者越大；其优点是：<u>不会去枚举到一定不满足条件的区间，同时也不会去枚举符合条件但一定不是答案的区间</u>。

尺取法比直接暴力枚举区间的效率高很多，尤其是数据量大的时候，所以尺取法是一种高效的枚举区间的方法，是一种**技巧**（涉及技巧就一定不是通解，使用的时候一定要注意条件），<u>一般用于求取有一定限制的区间个数或最短的区间</u>等，任何技巧都存在其不足的地方，在一些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算。

### LCR 008. 长度最小的子数组

https://leetcode.cn/problems/2VG8Kg/

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**数据范围**：

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

**思路**

尺取法的题目主要是如何把握边界情况，若`nums`中所有的元素和`<target`，答案则为0；用指针`left`确定窗口的左边界，指针`right`确定窗口的右边界，因为数组`nums`中的元素均为正数$nums[i]\in[1,1e5]$，所以当窗口扩大时，连续子数组之和`sum`也增大。

- 当`sum<target`时，通过右移指针`right`来扩大窗口
- 当`sum>target`时，右移指针`left`，尽可能的吐出数组元素。

