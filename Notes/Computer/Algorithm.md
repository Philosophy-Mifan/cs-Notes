```cpp
//Algorithm篇（C++），配合LeetCode和Luogu使用，所以在正式阅读本文之前，请先注册属于自己的账号，并且熟悉两个平台的用法。

//请在学习C++基础篇以及数据结构后阅读本文，本文重点教你如何刷题，以及部分常见算法题的思路。
//在学习每一章节之前，请先预习各个章节的第一部分，也就是至少先将题看一遍，且有自己大概的思路，再来学习本笔记。
//本笔记旨在整理课程内容，其目标如下：
1、学会做题——分析题意，寻找思路/确定算法，把思路转换成代码
2、巩固《数据结构》课程中的算法
3、学习一些《数据结构》课程中没有涉及到，但常用的算法：在算法比赛中（不包含ACM），春秋招笔试，考研复试（上机）中常出现的算法
4、课程结束后，希望大家都可以独立的在oj上刷题练习
```

## Chapter 0 序言

再次提醒，在学习对应的章节时，请务必确定自己学习了相应的数据结构，以及复习了相应的STL语法（可见《算法笔记》第6章）

1. 在本文中所使用的语言为C/C++，在学习以及自行做题时可以选用自己的主语言，并且添加到本文中以完善属于自己的笔记；
2. 本文中的例题均选自洛谷和Leetcode，自行做题时可以使用任意刷题网站（OJ）；
3. 对参加ACM（ICPC/CCPC）有帮助嘛？有，但远远不够，本文涉及到的算法只覆盖了蓝桥杯等比赛的**大部分**出题范围；
4. 在刷题时遇到不会的题，请**参照**题解（不要**照抄**），通过看题解中的思路转换为自己的思路，并自行完成代码的编写，如果一个题解看不懂，不要犹豫，换一个题解继续看，总会遇到适合你的题解，使用AI进行适当的辅助学习是事半功倍的。

在各平台提交题解时，请不要使用各平台网站自带的编译器，使用自己的编译器在本地通过测试用例后，再复制到网页中，在提交时你可能会遇到如下提示：

1. 答案正确 (Accepted, AC)：单点测试，每通过一组数据，就会返回一个AC；多点测试只有通过是有的数据之后才回返回一个AC
2. 编译错误(Compile Error, CE)：代码没有通过编译，看本地编译器是否能正常编译后，修改后重新提交
3. 答案错误(Wrong Answer, WA)：代码有漏洞或者是使用了错误的算法导致结果错误
4. 运行超时(Time Limit Exceeded, TLE)：运行时间超过允许上限，**死循环**的情况最常见
5. 运行错误(Running Error, RE)：造成这一错误的可能性很多：非法访问内存，浮点错误，递归爆栈等
6. 内存超限(Memory Limit Exceeded, MLE)：一般数组太大会导致这个问题
7. 格式错误(Presentation Error, PE)：最接近Accepted的错误，一般由多输出空格或者换行导致
8. 输出超限(Output Limit Exceeded, OLE)：一般由输出了大量调试信息或者特殊数据导致死循环输出导致



## Chapter 1 枚举&暴力

- 枚举：是基于已有知识来猜测答案的一种问题求解策略。枚举的思想是不断地猜测，从可能的答案集合中一一尝试，然后再判断题目的条件是否成立，枚举每一种可能性。
- 暴力：直接模拟题目中要求的操作来求解。模拟题目通常具有码量大、操作多的特点，由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的，但是其思路一般较为简单；还有一种搜索方式叫暴力搜索（暴搜）

:exclamation:枚举和暴力不做严格区分。



做题步骤：读题面，分析题意 -> 看示例，分析样例 -> 看数据范围，确定时间复杂度(1s = 10^8^) -> 找思路，写代码，本地运行测试，提交

### P1003 [NOIP 2011 提高组] 铺地毯

#### 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。

#### 输入格式

输入共 $n + 2$ 行。

第一行，一个整数 $n$，表示总共有 $n$ 张地毯。

接下来的 $n$ 行中，第 $i+1$ 行表示编号 $i$ 的地毯的信息，包含四个整数 $a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 $(a, b)$ 以及地毯在 $x$ 轴和 $y$ 轴方向的长度。

第 $n + 2$ 行包含两个整数 $x$ 和 $y$，表示所求的地面的点的坐标 $(x, y)$。

#### 输出格式

输出共 $1$ 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `-1`。

#### 输入输出样例 #1

##### 输入 #1

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

##### 输出 #1

```
3
```

#### 输入输出样例 #2

##### 输入 #2

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5
```

##### 输出 #2

```
-1
```

#### 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

<img src="https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png" alt=" " style="zoom:35%;" />

【数据范围】

对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

#### 思路

从后往前枚举地毯，如果有一个地毯满足条件则直接输出，并退出；如果没有地毯满足则返回-1。(满足条件：点的坐标在地毯的覆盖范围内)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;	//在做题时的变量名请和题中保持一致，保持可读性。
int a[10005],b[10005],x[10005],y[10005];	//开数组的技巧就是根据题目中给的上限多开几个，防止内存溢出
int sx, sy;	//地面的点
int main(){
    //input
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d %d %d %d", &a[i], &b[i], &c[i], &d[i]);
    }
    ans = -1;	//先认为没有地毯覆盖，随后在枚举中更新ans的值
    //枚举解题
    for(int i = n; i > 0; i--){
        if(sx>=a[i]&&sx<=a[i]+x[i]&&sy>=b[i]&&sy<=b[i]+y[i]){
            ans = i;
            break;
        }
    }
    printf("%d", ans);
    return 0;
}
```

